"""
POSITION SCALING QUICK REFERENCE

Decide whether to add to existing position. BLOCK by default.

============================================================================
WHAT IS THIS?
============================================================================

A production-grade decision engine for multi-entry position scaling.

When a strategy has existing position and new buy signal:
- Evaluate if safe/appropriate to add
- Return BLOCK (hard stop), SKIP (try later), or SCALE (execute)

Philosophy: Explicit opt-in. Hard safety enforcement. No implicit behavior.

============================================================================
WHEN TO USE
============================================================================

Strategy wants to add to positions?
  ├─ Pyramid (add at better prices)
  ├─ Average down (add at worse prices)
  └─ Systematic scaling (fixed plan)

If YES:
  1. Strategy declares scaling_policy (in config)
  2. Execution layer builds ScalingContext
  3. Call should_scale_position(context)
  4. Handle result (BLOCK/SKIP/SCALE)

If NO:
  1. Don't configure scaling_policy
  2. Scaling automatically blocks
  3. Zero changes needed

============================================================================
FILES TO KNOW
============================================================================

risk/scaling_policy.py
  ├─ StrategyScalingPolicy (config)
  ├─ ScalingContext (data)
  ├─ ScalingDecision (BLOCK|SKIP|SCALE)
  └─ ScalingDecisionResult (outcome + logging)

strategies/scaling_engine.py
  └─ should_scale_position(context) → ScalingDecisionResult

strategies/base.py
  └─ Strategy.scaling_policy property

tests/test_scaling_engine.py
  └─ 30 unit tests (all passing)

examples/scaling_examples.py
  └─ Real-world examples

docs/POSITION_SCALING_GUIDE.md
  └─ Full integration guide

============================================================================
QUICK START: 3 STEPS
============================================================================

Step 1: Configure strategy for scaling
────────────────────────────────────────
config = {
    "enabled": True,
    "scaling_policy": {
        "allows_multiple_entries": True,
        "max_entries_per_symbol": 3,
        "scaling_type": "pyramid",
        "min_bars_between_entries": 5,
    }
}
strategy = SwingEquityStrategy("swing", config)

Step 2: When position exists, build context
────────────────────────────────────────────
from risk.scaling_policy import ScalingContext

context = ScalingContext(
    symbol=symbol,
    current_signal_confidence=confidence,
    proposed_entry_price=price,
    proposed_entry_size=size,
    # ... populate all fields from broker/ledger/market data
    scaling_policy=strategy.scaling_policy,
)

Step 3: Make decision
──────────────────────
from strategies.scaling_engine import should_scale_position

result = should_scale_position(context)
result.log(context)  # Structured audit trail

if result.decision == ScalingDecision.SCALE:
    execute_buy_order(symbol, size, price)
elif result.decision == ScalingDecision.SKIP:
    pass  # Try next signal
else:  # BLOCK
    logger.error(f"Scaling blocked: {result.reason_text}")

============================================================================
DECISION OUTCOMES
============================================================================

SCALE (Green Light)
  ├─ All checks passed
  ├─ Safe to add position
  ├─ Log: INFO level
  └─ Action: EXECUTE BUY ORDER

SKIP (Yellow Light)
  ├─ Conditions not met (timing, signal quality)
  ├─ Not a safety violation
  ├─ Log: INFO level
  └─ Action: DO NOTHING, TRY AGAIN LATER

BLOCK (Red Light)
  ├─ Safety constraint violated
  ├─ DO NOT ADD POSITION
  ├─ Log: WARNING level
  └─ Action: FIX ISSUE, THEN RETRY

============================================================================
HARD BLOCKS (Always Stop)
============================================================================

1. Strategy doesn't allow scaling
   Config missing "allows_multiple_entries": True

2. Max entries exceeded
   Already at max_entries_per_symbol

3. Position too large
   Would exceed max_total_position_pct of account

4. Pending order exists
   Prevents duplicate order submission

5. Broker/Ledger mismatch
   Broker qty ≠ Ledger qty (reconciliation issue)

6. Risk budget exceeded
   Proposed risk > available_risk_budget

7. Directional conflict
   Signal direction ≠ position direction

⚠️  These cannot be waived. Always BLOCK.

============================================================================
SOFT SKIPS (Can Defer)
============================================================================

1. Minimum time not elapsed
   Wait min_time_between_entries_seconds

2. Minimum bars not elapsed
   Wait min_bars_between_entries bars

3. Signal quality too low
   Wait for stronger signal (higher confidence)

4. Bearish divergence detected
   Wait for confirmation

5. Price structure wrong (pyramid)
   Entry price must be > last entry price
   OR: No lower low must exist

6. Price structure wrong (average)
   Entry price must be < last entry price
   OR: Drawdown must be <= max_atr_multiple

7. Volatility too low
   ATR must be > rolling_median

✓ These return SKIP. Try again later.

============================================================================
SCALING TYPES
============================================================================

PYRAMID (Momentum-Based)
  ├─ Add at better prices (higher for long)
  ├─ Require signal strength >= first entry
  ├─ No lower low since last entry
  ├─ Works best in trending markets
  └─ Conservative: fewer, larger entries

AVERAGE (Value-Based)
  ├─ Add at worse prices (lower for long)
  ├─ Can add with lower signal quality
  ├─ Max drawdown limit (ATR-based)
  ├─ Works in ranging markets
  └─ Aggressive: more, smaller entries

============================================================================
CONFIGURATION TEMPLATE
============================================================================

Single-Entry (Default):
────────────────────────
config = {"enabled": True}
# No scaling_policy → blocks on existing position

Pyramid (3 Entries):
────────────────────
config = {
    "enabled": True,
    "scaling_policy": {
        "allows_multiple_entries": True,
        "max_entries_per_symbol": 3,
        "max_total_position_pct": 5.0,
        "scaling_type": "pyramid",
        "min_bars_between_entries": 5,
        "min_time_between_entries_seconds": 300,
        "min_signal_strength_for_add": 4.0,
    }
}

Average-Down (4 Entries):
─────────────────────────
config = {
    "enabled": True,
    "scaling_policy": {
        "allows_multiple_entries": True,
        "max_entries_per_symbol": 4,
        "max_total_position_pct": 8.0,
        "scaling_type": "average",
        "min_bars_between_entries": 10,
        "max_atr_drawdown_multiple": 2.0,
    }
}

============================================================================
LOG READING GUIDE
============================================================================

Log Format:
SCALING DECISION: {BLOCK|SKIP|SCALE} | Symbol: {SYM} |
Strategy: {STRAT} | Reason: {CODE} | Entries: {N}/{MAX} |
Position %: {P}% | Risk: ${R} | Text: {EXPLANATION}

Example SCALE:
INFO | SCALING DECISION: SCALE | Symbol: AAPL | Strategy: swing |
Reason: strategy_disallows_scaling | Entries: 1/3 | Position %: 2.50% |
Risk: $350.00 | Text: All scaling checks passed.
→ Action: ORDER PLACED

Example SKIP:
INFO | SCALING DECISION: SKIP | Symbol: MSFT | Strategy: swing |
Reason: minimum_bars_not_met | Entries: 1/3 | Position %: 0.00% |
Risk: $0.00 | Text: Only 3 bars, need 5.
→ Action: WAIT, TRY NEXT SIGNAL

Example BLOCK:
WARNING | SCALING DECISION: BLOCK | Symbol: TSLA | Strategy: swing |
Reason: max_entries_exceeded | Entries: 3/3 | Position %: 0.00% |
Risk: $0.00 | Text: Max reached.
→ Action: CLOSE POSITION BEFORE ADDING

============================================================================
TESTING
============================================================================

Run Tests:
  PYTHONPATH=. python3 -m unittest tests.test_scaling_engine -v

Run Examples:
  PYTHONPATH=. python3 examples/scaling_examples.py

Expected Results:
  ✓ 30 unit tests pass
  ✓ All examples complete
  ✓ Structured logs appear

============================================================================
COMMON PATTERNS
============================================================================

Pattern: Block scaling for illiquid symbols
───────────────────────────────────────────
if symbol in ['LOW_VOLUME_SYMBOLS']:
    policy.allows_multiple_entries = False

Pattern: Tighter limits in high volatility
──────────────────────────────────────────
if market_vol > threshold:
    policy.max_entries_per_symbol = 1
    policy.max_total_position_pct = 3.0

Pattern: Require higher signal quality for adds
───────────────────────────────────────────────
policy.min_signal_strength_for_add = first_entry_confidence + 1

Pattern: Adaptive thresholds by market regime
──────────────────────────────────────────────
if is_bear_market():
    policy.requires_volatility_above_median = True
else:
    policy.requires_volatility_above_median = False

============================================================================
TROUBLESHOOTING
============================================================================

❌ "BLOCK | broker_ledger_mismatch"
   → Broker qty ≠ Ledger qty
   → Fix: Reconcile positions before trading
   → Action: Check trade_ledger vs broker.get_position()

❌ "BLOCK | max_entries_exceeded"
   → Already at max positions
   → Fix: Close one position before adding
   → Action: This is intentional safety limit

❌ "SKIP | minimum_bars_not_met"
   → Not an error, timing constraint
   → Fix: Wait for next bar(s)
   → Action: Normal operation, try again later

❌ "SKIP | price_structure_violation"
   → Price doesn't match scaling type
   → Pyramid: Entry must be > last entry
   → Average: Entry must be < last entry
   → Fix: Wait for correct price

❌ System not scaling
   → Check config has "allows_multiple_entries": True
   → Check position exists (not first entry)
   → Check logs for BLOCK/SKIP reason

============================================================================
INTEGRATION CHECKLIST
============================================================================

□ 1. Read docs/POSITION_SCALING_GUIDE.md
□ 2. Run examples: python3 examples/scaling_examples.py
□ 3. Run tests: python3 -m unittest tests.test_scaling_engine -v
□ 4. Configure strategy with scaling_policy
□ 5. Build ScalingContext in execution layer
□ 6. Call should_scale_position(context)
□ 7. Handle BLOCK/SKIP/SCALE outcomes
□ 8. Log via result.log(context)
□ 9. Test with paper trading
□ 10. Deploy with confidence

============================================================================
KEY CONCEPTS
============================================================================

StrategyScalingPolicy
  Strategy's declaration: "I allow scaling, here's how"
  Immutable during trading session
  Validated at initialization

ScalingContext
  Complete snapshot for evaluation
  All data needed to make decision
  Immutable during evaluation

ScalingDecisionResult
  Outcome: BLOCK | SKIP | SCALE
  Reason code: specific check that failed
  Reason text: human-readable explanation
  Structured logging

should_scale_position()
  Main function you call
  Returns ScalingDecisionResult
  Runs 4 phases in order
  Returns first failure or SCALE

============================================================================
PHILOSOPHY
============================================================================

✓ Explicit over implicit
  No guessing strategy intent

✓ Safety first
  Default = BLOCK

✓ Fail fast
  Return first blocking issue

✓ Audit trail
  Every decision logged

✓ Testable
  Small, pure functions

✓ Backward compatible
  Single-entry strategies unchanged

============================================================================
"""

if __name__ == "__main__":
    print(__doc__)
